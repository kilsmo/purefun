# Purefun Package Manager (ppm)

Purefun includes a built-in package manager called ppm, fully integrated into the purefun command. The goal is to provide a deterministic, minimal, and safe module system that follows Purefun’s philosophy: simplicity, purity, and predictability.
This document describes the structure of Purefun products, dependency handling, and how to publish modules to ppm.

## 1. Overview

Purefun uses two configuration files:

* `source.ppm` – written by the developer

* `frozen.ppm` – generated by the tool, never edited manually

A Purefun product is defined by `source.ppm`, which declares:

* the product name

* the product version

* the entry file

* its dependencies

The `purefun` command resolves dependencies, compiles, runs, and publishes modules.

## 2. The `purefun` Command

All package-related operations are performed through the single command:

`purefun <action>`

Available actions (current set):

* `purefun build` – resolves dependencies and compiles the product

* `purefun run` – builds and runs the entry file

* `purefun publish` – publishes a module to ppm

* `purefun freeze` – generates `frozen.ppm` from `source.ppm`

More actions may be added later as the ecosystem grows.

## 3. `source.ppm`

`source.ppm` is a declarative configuration file. It is intentionally simple and resembles Purefun’s aesthetic: indentation, structure, and single-quoted strings.

Example:

```
product
  'my-app'
  '0.2.0'

entry
  './main.fun'

dependencies
  'fun/io' '1'
  'math'   '1.3'
```

### Meaning

* **product**

  First line is the product name, second is its version.


* **entry**

  A single file containing the program’s entry point.


* **dependencies**

  Each dependency is defined as:

  ```'module-name' 'version-range'```

Version ranges follow Purefun’s simplified semantic version matching:

* `'1'`   → matches any `1.x.x`

* `'1.3'` → matches any `1.3.x`

* `'1.3.5'` → matches exactly that version

The purefun tool resolves these to exact versions and writes them to `frozen.ppm`.

## 4. `frozen.ppm`

`frozen.ppm` is automatically generated and pinned. It contains exact versions for all dependencies, including transitive ones.

Example:

```
product
  'my-app'
  '0.2.0'

entry
  './main.fun'

dependencies
  'fun/io' '1.0.0'
  'math'   '1.3.2'
```

This file ensures deterministic builds and must be checked into version control. Developers never edit it manually.

## 5. Publishing Modules to ppm

A ppm module is always a single `.fun` file. The entire file is uploaded, but:

* only pure and tail functions are exported to consumers

* side-effectful helpers and top-level expressions remain internal

To publish a new version of a module, use:

```purefun publish ./module.fun --bump <type>```

where `<type>` is one of:

* patch

* minor

* major


### 5.1 Version Bump Rules

Assume the current published version is `1.3.2`.

`--bump patch`

`1.3.3`

Used for:

* refactoring

* performance improvements

* changes to internal helpers

* no changes to exported pure/tail functions

`--bump minor`

`1.4.0`

Used when:

* new exported pure/tail functions are added

* no breaking changes occur

`--bump major`

`2.0.0`

Required when:

* an exported function is removed

* a function’s signature changes

* observable behavior of exported pure functions is altered

### 5.2 Publishing Workflow

1. purefun reads the module’s current version from the ppm registry.

2. Calculates the new version based on `--bump`. ppm checks if it is possible to release a minor/patch version by analyzing the current code, and if releasing a new minor version or new patch version breaks the stability rules, the bump will fail, and there will be no version uploaded to ppm.

3. Compiles the module and verifies that all exported functions are pure/tail.

4. Removes access to side-effect helpers and top-level expressions.

5. Uploads the module file to the registry with the new version.

If the module breaks purity rules, the publish command fails.

## 6. How Dependency Resolution Works

1. Developer writes source.ppm with version ranges.

2. Running purefun build or purefun run triggers resolution.

3. For each dependency:

    *  find the highest compatible version that satisfies the range

    * ensure consistency across all transitive dependencies

4. The final resolved versions are written to `frozen.ppm`.

5. Build and execution use only the pinned versions in `frozen.ppm`.

Purefun always guarantees that a product uses exactly one version of each module throughout its dependency tree.

## 7. Philosophy

The ppm system follows Purefun’s core goals:

* **Purity enforcement** ensures safety

* **Implicit exports** reduce friction

* **Single command** reduces complexity

* **Deterministic builds** via `frozen.ppm`

* **Readable configuration** in a purefun-like style

Dependencies, module boundaries, and versioning remain predictable and pleasant.
